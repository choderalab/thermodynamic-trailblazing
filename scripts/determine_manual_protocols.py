#!/usr/env/python

"""
This script automatically prints "manual" alchemical paths for all the
YANK calculations starting from the average number of states found by
the trailblaze calculations.

"""

import glob
import os

import numpy as np

from utils.protocol import read_experiment_protocol, format_protocol


def read_all_protocols(verbose=False):
    """Read all the protocols generated by the trailblazing algorithm for the calculations.

    Returns
    -------
    all_protocols : Dict[str, Dict[str, Dict[str, Dict[str, List[Dict[str, List[float]]]]]]]
        all_protocols[thermo_distance][system_name][ligand_id][phase_name][replicate_idx][parameter_name][state_idx]
    """
    thermo_distances = ['05short', '10', '20', '35']
    system_ids = [
        ('CB8', ['1', '2', '5', '6']),
        ('T4', ['4', '6', '9', '14'])
    ]
    phase_names = ['complex', 'solvent']

    # Determine one manual protocol per thermodynamic distance, system, and phase.
    all_protocols = {}
    for thermo_distance in thermo_distances:
        all_protocols[thermo_distance] = {}
        for system_name, ligand_ids in system_ids:
            # TODO: REMOVE ME - We don't have 05short and 35 protocols for T4 for now.
            if system_name == 'T4' and (thermo_distance == '05short' or thermo_distance == '35'):
                continue

            all_protocols[thermo_distance][system_name] = {}
            for ligand_id in ligand_ids:
                all_protocols[thermo_distance][system_name][ligand_id] = {
                    phase_name: [] for phase_name in phase_names
                }

                # Determine the pattern to the experiment directories.
                experiment_dir_pattern = os.path.join(
                    '..', 'yank', 'experiments', f'experiment-{system_name}-*', f'trailblaze{thermo_distance}*ligands{ligand_id}*')

                # Read the protocols and add it to the list.
                for experiment_dir_path in glob.glob(experiment_dir_pattern):
                    experiment_protocol = read_experiment_protocol(experiment_dir_path)
                    for phase_name, phase_protocol in experiment_protocol.items():
                        all_protocols[thermo_distance][system_name][ligand_id][phase_name].append(phase_protocol)

    return all_protocols


def generate_manual_protocol(n_states, phase_name):
    """Generate a manual protocol.

    The states are separated by a constant lambda interval with the
    electrostatics turned off twice as fast as the Lennard-Jones interactions.
    The restraint is always turned off in a single lambda.
    """
    # Determine the number of states for restraint, electrostatics and sterics.
    # Only the complex phase has restraints.
    if phase_name == 'complex':
        n_restraint_states = 1
    elif phase_name == 'solvent':
        n_restraint_states = 0
    n_electrostatics_states = round((n_states - n_restraint_states) / 3)
    n_sterics_states = n_states - n_restraint_states - n_electrostatics_states

    # Determine the protocol.
    protocol = {}
    if n_restraint_states > 0:
        protocol['lambda_restraints'] = [0.0] * n_restraint_states + [1.0] * (n_electrostatics_states + n_sterics_states)
    windows = np.linspace(1.0, 0.0, n_electrostatics_states).tolist()
    protocol['lambda_electrostatics'] = [1.0] * n_restraint_states + windows + [0.0] * n_sterics_states
    # TODO: In the first version of the manual one-path-fits-all protocols, I
    # forgot to add the 1 here and the -1 below so that two states were identical.
    windows = np.linspace(1.0, 0.0, n_sterics_states+1).tolist()
    protocol['lambda_sterics'] = [1.0] * (n_restraint_states + n_electrostatics_states - 1) + windows

    for parameter_values in protocol.values():
        assert len(parameter_values) == n_states
    return protocol


def print_phase_protocols(protocols):
    """Print the protocols directly in YAML format."""
    for protocol_name, phases_protocols in protocols.items():
        print(f'\n  {protocol_name}:')
        for phase_name, phase_protocol in phases_protocols.items():
            print(f'    {phase_name}:')
            print(f'      alchemical_path:')
            print(format_protocol(phase_protocol, indent=8))


def determine_one_path_fits_all_protocols(print_n_states_info=True):
    """Create the manual one-path-fits-all protocols to run for trailblaze.

    The protocols have the same number of states as the average number of
    states generated by trailblaze for the congeneric series (i.e. one
    per receptor) and thermodynamic distance parameter.

    """
    # Read all the protocols.
    all_protocols = read_all_protocols(verbose=True)

    # Determine the average number of states for each thermo distance, system, and phase.
    all_manual_protocols = {}
    for thermo_distance, distance_protocols in all_protocols.items():
        for system_name, system_protocols in distance_protocols.items():
            # There should be 4 ligands for each system.
            assert len(system_protocols) == 4

            # Create a name for the protocol.
            protocol_name = f'manual-{thermo_distance}-{system_name}'
            all_manual_protocols[protocol_name] = {}

            # Info about average number of states.
            if print_n_states_info:
                print(protocol_name)

            # Find the length of the protocols for each system.
            protocol_lengths = {phase_name: [] for phase_name in ['complex', 'solvent']}
            for ligand_id, ligand_protocols in system_protocols.items():
                for phase_name, phase_protocols in ligand_protocols.items():
                    # There should be 10 replicates for CB8 (it has the unseeded) and 5 for T4.
                    if 'CB8' in system_name:
                        n_expected_protocol = 10
                    else:
                        n_expected_protocol = 5
                    assert len(phase_protocols) == n_expected_protocol, f'{protocol_name}-{phase_name}: {len(phase_protocols)}'

                    # Add the number of states for these three replicates.
                    protocol_lengths[phase_name].extend(len(p['lambda_sterics']) for p in phase_protocols)

            # Determine the manual for this thermo distance, and system.
            for phase_name, phase_n_states in protocol_lengths.items():
                # Determine average number of states.
                avg_n_states = round(sum(phase_n_states) / len(phase_n_states))

                # Print info about number of states. Note that, because we add the
                # protocol lengths ligand by ligand, the replicates are grouped together.
                if print_n_states_info:
                    min_len = min(protocol_lengths[phase_name])
                    max_len = max(protocol_lengths[phase_name])
                    print(f'\t{phase_name}: {protocol_lengths[phase_name]} (avg={avg_n_states}, range=[{min_len}, {max_len}])')

                # Obtain the manual protocol.
                manual_protocol = generate_manual_protocol(avg_n_states, phase_name)
                all_manual_protocols[protocol_name][phase_name] = manual_protocol

    # Pretty print all protocols.
    print()
    # print_phase_protocols(all_manual_protocols)


def determine_all_ligand_manual_protocols(print_n_states_info=True):
    """Create the 'manual' protocols to run for trailblaze.

    The protocols have the same number of states as the average number of
    states generated by trailblaze for the congeneric series (i.e. one
    per receptor) and thermodynamic distance parameter.

    """
    # Read all the protocols.
    all_protocols = read_all_protocols(verbose=True)

    # Determine the average number of states for each thermo distance, system, and phase.
    all_manual_protocols = {}
    for thermo_distance, distance_protocols in all_protocols.items():
        for system_name, system_protocols in distance_protocols.items():
            # There should be 4 ligands for each system.
            assert len(system_protocols) == 4

            # Find the the protocols for each system.
            for ligand_id, ligand_protocols in system_protocols.items():
                # Create a name for the protocol.
                protocol_name = f'manual-{thermo_distance}-{system_name}-ligand{ligand_id}'
                all_manual_protocols[protocol_name] = {}

                # Info about average number of states.
                if print_n_states_info:
                    print(protocol_name)

                for phase_name, phase_protocols in ligand_protocols.items():
                    # There should be 10 replicates for CB8 (it has the unseeded) and 5 for T4.
                    if 'CB8' in system_name:
                        n_expected_protocol = 10
                    else:
                        n_expected_protocol = 5
                    assert len(phase_protocols) == n_expected_protocol, f'{protocol_name}-{phase_name}: {len(phase_protocols)}'

                    # Add the number of states for these three replicates.
                    protocol_lengths = [len(p['lambda_sterics']) for p in phase_protocols]

                    # Determine average number of states.
                    avg_n_states = round(sum(protocol_lengths) / len(protocol_lengths))

                    # Print info about number of states. Note that, because we add the
                    # protocol lengths ligand by ligand, the replicates are grouped together.
                    if print_n_states_info:
                        min_len = min(protocol_lengths)
                        max_len = max(protocol_lengths)
                        print(f'\t{phase_name}: {protocol_lengths} (avg={avg_n_states}, range=[{min_len}, {max_len}])')

                    # Obtain the manual protocol.
                    manual_protocol = generate_manual_protocol(avg_n_states, phase_name)
                    all_manual_protocols[protocol_name][phase_name] = manual_protocol

    # Pretty print all protocols.
    print()
    # print_phase_protocols(all_manual_protocols)


if __name__ == '__main__':
    # determine_one_path_fits_all_protocols(print_n_states_info=True)
    determine_all_ligand_manual_protocols(print_n_states_info=True)
